#[cfg(test)]
mod test_option_calculations {
    use optifi::financial::*;

    #[test]
    fn test_d1_single() {
        let spot = 33880.0;
        let strike = 39000.0;
        let iv = 1.0;
        let r = 0.0;
        let q = 0.0;
        let t = 0.0254814;
        let price = d1_single(spot, strike, iv, r, q, t);
        println!("{}", price);

        assert_eq!(price, -0.8018350090033548);
    }

    #[test]
    fn test_d2_single() {
        let spot = 33880.0;
        let strike = 39000.0;
        let iv = 1.0;
        let r = 0.0;
        let q = 0.0;
        let t = 0.0254814;
        let price = d2_single(spot, strike, iv, r, q, t);
        println!("{}", price);

        assert_eq!(price, -0.9614639537470948);
    }

    #[test]
    fn test_d1_with_single_spot() {
        let spot = *config::SPOT; // 48400
        let strikes = config::STRIKE.to_vec();
        let iv = *config::IV; // 1.0
        let r = *config::RATE; // 0.0
        let q = *config::DVD_YLD; // 0.0
        let t = config::TIME_TO_MATURITY.to_vec();

        let spots: SpotInputOption = SpotInputOption::SingleSpot(spot);

        let price = d1(spots, strikes, iv, r, q, &t);

        println!("{:?}", price);
        assert_eq!(price.len(), 28)
    }

    #[test]
    fn test_d1_with_multi_spot() {
        // Mock stress spot generated by `def generate_stress_spot(spot, stress, step)` in python
        let generated_stress_spot: Vec<Vec<f64>> = [[
            33880, 36784, 39688, 42592, 45496, 48400, 51304, 54208, 57112, 60016, 62920,
        ]]
        .iter()
        .map(|e| e.iter().map(|n| *n as f64).collect())
        .collect();
        let spots = SpotInputOption::MultiSpots(generated_stress_spot);

        let strikes = config::STRIKE.to_vec();
        let iv = *config::IV; // 1.0
        let r = *config::RATE; // 0.0
        let q = *config::DVD_YLD; // 0.0
        let t = config::TIME_TO_MATURITY.to_vec();

        let price = d1(spots, strikes, iv, r, q, &t);
        println!("{:?}", price);
        assert_eq!(price.len(), 28)
    }

    #[test]
    fn test_d2_with_single_spot() {
        let spot = *config::SPOT; // 48400
        let strikes = config::STRIKE.to_vec();
        let iv = *config::IV; // 1.0
        let r = *config::RATE; // 0.0
        let q = *config::DVD_YLD; // 0.0
        let t = config::TIME_TO_MATURITY.to_vec();

        let spots: SpotInputOption = SpotInputOption::SingleSpot(spot);

        let price = d2(spots, strikes, iv, r, q, &t);

        println!("{:?}", price);
        assert_eq!(price.len(), 28)
    }

    #[test]
    fn test_d2_with_multi_spot() {
        // Mock stress spot generated by `def generate_stress_spot(spot, stress, step)` in python
        let generated_stress_spot: Vec<Vec<f64>> = [[
            33880, 36784, 39688, 42592, 45496, 48400, 51304, 54208, 57112, 60016, 62920,
        ]]
        .iter()
        .map(|e| e.iter().map(|n| *n as f64).collect())
        .collect();
        let spots = SpotInputOption::MultiSpots(generated_stress_spot);

        let strikes = config::STRIKE.to_vec();
        let iv = *config::IV; // 1.0
        let r = *config::RATE; // 0.0
        let q = *config::DVD_YLD; // 0.0
        let t = config::TIME_TO_MATURITY.to_vec();

        let price = d2(spots, strikes, iv, r, q, &t);
        println!("{:?}", price);
        assert_eq!(price.len(), 28)
    }

    #[test]
    fn test_option_price_with_multi_spot() {
        // run the test for 1000 times and see the time used
        let mut a = 0;
        while a < 10000 {
            // Mock stress spot generated by `def generate_stress_spot(spot, stress, step)` in python
            let generated_stress_spot: Vec<Vec<f64>> = [[
                33880, 36784, 39688, 42592, 45496, 48400, 51304, 54208, 57112, 60016, 62920,
            ]]
            .iter()
            .map(|e| e.iter().map(|n| *n as f64).collect())
            .collect();
            let spots = SpotInputOption::MultiSpots(generated_stress_spot);

            let strikes = config::STRIKE.to_vec();
            let iv = *config::IV; // 1.0
            let r = *config::RATE; // 0.0
            let q = *config::DVD_YLD; // 0.0
            let t = config::TIME_TO_MATURITY.to_vec();
            let is_call = config::IS_CALL.to_vec();

            let price = option_price(&spots, &strikes, iv, r, q, &t, &is_call);

            println!("{:?}", price);
            // assert_eq!(price.len(), 100000);
            a = a + 1;
        }
    }

    #[test]
    fn test_option_delta_with_single_spot() {
        let spot = *config::SPOT; // 48400
        let spots: SpotInputOption = SpotInputOption::SingleSpot(spot);
        let strikes = config::STRIKE.to_vec();
        let iv = *config::IV; // 1.0
        let r = *config::RATE; // 0.0
        let q = *config::DVD_YLD; // 0.0
        let t = config::TIME_TO_MATURITY.to_vec();
        let is_call = config::IS_CALL.to_vec();

        let delta = option_delta(&spots, &strikes, iv, r, q, &t, &is_call);

        println!("{:?}", delta);
        assert_eq!(delta.len(), 28)
    }

    #[test]
    fn test_option_intrinsic_value_with_single_spot() {
        let spot = *config::SPOT; // 48400
        let spots: SpotInputOption = SpotInputOption::SingleSpot(spot);
        let strikes = config::STRIKE.to_vec();
        let is_call = config::IS_CALL.to_vec();

        let delta = option_intrinsic_value(&spots, &strikes, &is_call);

        println!("{:?}", delta);
        assert_eq!(delta.len(), 28)
    }

    #[test]
    fn test_option_reg_t_margin_with_single_spot() {
        let spot = *config::SPOT; // 48400
        let spots: SpotInputOption = SpotInputOption::SingleSpot(spot);
        let strikes = config::STRIKE.to_vec();
        let stress = *config::SPOT_STRESS; // 0.3
        let is_call = config::IS_CALL.to_vec();

        let delta = option_reg_t_margin(&spots, &strikes, stress, &is_call);

        println!("{:?}", delta);
        assert_eq!(delta.len(), 28)
    }

    #[test]
    fn test_generate_stress_spot_with_single_spot() {
        let spot = *config::SPOT; // 48400
        let stress = *config::SPOT_STRESS; // 0.3
        let step: u8 = 5;

        let delta = generate_stress_spot(spot, stress, step);

        println!("{:?}", delta);
        // assert_eq!(delta.len(), 28)
    }

    #[test]
    fn test_stress_function_with_single_spot() {
        let mut a = 0;
        while a < 1 {
            let spot = *config::SPOT; // 48400
            let strikes = config::STRIKE.to_vec();
            let iv = *config::IV; // 1.0
            let r = *config::RATE; // 0.0
            let q = *config::DVD_YLD; // 0.0
            let t = config::TIME_TO_MATURITY.to_vec();
            let stress = *config::SPOT_STRESS; // 0.3
            let is_call = config::IS_CALL.to_vec();
            let step: u8 = 5;

            let stress_function_res =
                stress_function(spot, strikes, iv, r, q, &t, stress, is_call, step);
            println!("{:?}", stress_function_res);
            // assert_eq!(delta.len(), 28)
            a = a + 1;
        }
    }

    #[test]
    fn test_margin_function_with_single_spot() {
        let spot = *config::SPOT; // 48400
        let strikes = config::STRIKE.to_vec();
        let iv = *config::IV; // 1.0
        let r = *config::RATE; // 0.0
        let q = *config::DVD_YLD; // 0.0
        let t = config::TIME_TO_MATURITY.to_vec();
        let stress = *config::SPOT_STRESS; // 0.3
        let is_call = config::IS_CALL.to_vec();
        let step: u8 = 5;

        let user1 = config::USER_POSITION_3.to_vec(); // 0.3

        let stress_function_res: StressFunctionResult =
            stress_function(spot, strikes, iv, r, q, &t, stress, is_call, step);
        // println!("{:?}", stress_function_res);
        // assert_eq!(delta.len(), 28)

        let price = stress_function_res.price;
        let intrinsic = stress_function_res.intrinsic_value;
        let stress_price_change = stress_function_res.stress_price_delta;

        let margin_results_user1 =
            margin_function(user1, spot, &t, price, intrinsic, stress_price_change);
        println!("{:?}", margin_results_user1);
    }

    #[test]
    fn test_cdf() {
        let val = cdf(1.65);
        print!("{}", val);
        assert_eq!(val, 0.9505285319663519)
    }
}
